<!DOCTYPE html>
<!-- saved from url=(0063)https://www.cse.unsw.edu.au/~cs3421/17s2/assignments/assn1.html -->
<html class="gr__cse_unsw_edu_au"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Assignment 1 </title>
<link rel="stylesheet" type="text/css" href="./Assignment 1_files/style.css">
</head>
<body data-gr-c-s-loaded="true">
<h1>Assignment 1 : A 2D Game Engine </h1>
<h3> Due: Fri Sep  1, 2017, 23:59:59 </h3>
<h3> Late penalty: Penalties are off the maximum mark. 1.5 marks/day and 1 mark/day 
for the bonus game</h3>
<h3> Marks: 15 Marks plus up to 3 Bonus Marks </h3>

<p>Note on bonus marks policy: bonus marks do not carry across to make up
for final exam marks. They can only count towards the 40% allocated to assignment marks.
</p>
<br>
<h1>Changes and Corrections</h1>
<ul>
<li>
12/08/2017 Modified some misleading comments in GameObject.java. The comment should be //myRotation should be normalised to the range [-180..180). 
</li><li>
12/08/2017 Modified another misleading comment in TestShapes.java. The comment should be //Create a circle that is a child of polygon p
</li><li>
15/08/2017 Modified the main functions in TestMyCoolGameObject.java SailingGame.java to set the surface scale correctly.
</li><li>
16/08/2017 Added another constructor to PolygonalGameObject.java to make it work with the sailing game. If you are not trying to run the sailing game, this is not needed.
<pre>import java.util.ArrayList;

public PolygonalGameObject(GameObject parent, double points[],
            double[] fillColour, double[] lineColour) {
        super(parent);

        myPoints = new ArrayList<double[]>();
        for(int i = 0; i &lt; points.length; i+=2){
        	 myPoints.add(new double[]{points[i],points[i+1]});
        }
        myFillColour = fillColour;
        myLineColour = lineColour;
    }    

</double[]></pre>
 The updated file is in the base classes zip. Or here: Be careful not to download and overwrite anything you have already done in your assignment.
<a href="https://www.cse.unsw.edu.au/~cs3421/17s2/assignments/ass1/PolygonalGameObject.java">PolygonalGameObject.java</a>

</li></ul>

<h1>Intro</h1>
<p>For the first assignment you will be building a simple 2D game engine.</p>
<p>This is an individual assignment </p>
<p>The aim of this assignment is to test:</p>
<ol>
<li>Your understanding of the idea of a <strong>scene graph</strong>.</li>
<li>Your understanding of <strong>2D affine transforms</strong> (translation, rotation, scale)</li>
<li>Your ability to set the <strong>model-view transform</strong> in OpenGL</li>
<li>Your ability to use the <strong>orthogonal projection</strong>.</li>
<li>Your ability to <strong>draw</strong> simple shapes.</li>
<li>Your ability to <strong>model</strong> a simple scene using the scene graph</li>
</ol>
<h1>Task</h1>
<p>You task is to complete the implementation of a scene-graph based game engine&nbsp;and use it to make a simple game (or animation). 
The engine is designed to allow a games programmer to implement simple 2D objects, connect them in a scene-graph (in this case, a tree) and animate them in response to user input.</p>
<h3>Files</h3>
<p><a href="http://www.cse.unsw.edu.au/~cs3421/17s2/assignments/ass1-base.zip" target="_blank">Download a set of base classes here</a>. These classes implement the basic data-structures, but are incomplete. The files provided are:</p>
<ol>
<li><strong>GameEngine</strong> - the GLEventListener which handles init(), 
dispose(), update() and display() methods, mostly by passing them off to other 
components. You should read and understand this class but you should not need to 
modify it unless you do the bonus collision testing part.</li>
<li><strong>GameObject</strong> - an object in the scene-graph. This class represents 
a node in the tree structure, with its own local coordinate frame. You will need to complete code to calculate the global position of this node, and to compute the model&nbsp;transform for its coordinate frame.</li>
<li><strong>PolygonalGameObject</strong> - an extension of GameObject that represents a convex polygon. You will need to complete code to draw the polygon in the local coordinate frame.</li>
<li><strong>Camera</strong> - an extension of GameObject that represents the camera. You will need to complete code to compute the view transform for the camera's position and orientation.</li>
<li><strong>MathUtil</strong> - a small library of math functions that you may find useful, including matrix multiplication. You will need to complete methods to construct matrices for translation, rotation and scaling.</li>
<li><strong>Mouse</strong> - a singleton class that keeps track of mouse button presses and mouse movement in world coordinates. You should not need to modify this class.</li>
</ol>
<p>We will be using automarking to test some of these classes, so you 
need to make sure you <strong>do not change class names or method 
signatures</strong>. You may add additional classes and methods as you wish.</p>
<h3>Detail</h3>
<p>All the methods and classes you need to implement have been marked with the 
<strong>TODO</strong> tag. They are described in detail below</p>
<h4>MathUtil</h4>
<pre class="prettyprint linenums">public static double[][] translationMatrix(double[] v)
public static double[][] rotationMatrix(double angle)
public static double[][] scaleMatrix(double scale)
</pre>
<p>These three methods should return 3x3 arrays of doubles representating a 2D translation, rotation and scale matrix respectively, to apply to a vector in homogeneous coordinations. The matrices should be specified in (row, column) order. So m[2][1] refers to the entry in row 2, col 1.&nbsp;</p>
<p>
</p><p>We have provided a class called MathUtilTest.java. This is a junit test class that you can use as a starting point to test your MathUtil class.

</p><h4>GameObject</h4>
<p> A GameObject is an object that can move around in the game world. GameObjects are basically the 'nodes' that form a scene tree. The root of the tree is the special ROOT object. Each GameObject has a parent (which is null for the root node) and a list of children. Each GameObject is offset from its parent by a rotation, a translation and a scale factor. To simplify the maths involved in the assignment, we assume that transformations are always done in the order, Translate, Rotate, then Scale and that scaling is always uniform (ie we can't scale x and y axes by different amounts).
</p><p>The methods that need to be implemented in this class include:
</p><pre><span>public</span> <span>void</span> draw(GL2 gl)</pre>
<p>This method needs to:</p>
<ol>
<li>Update the model transform appropriately to establish the local coordinate frame for this object.</li>
<li>Call drawSelf() to draw the object.</li>
<li>Call draw() recursively on all children objects</li>
</ol>
<pre><span>public</span> <span>double</span>[] getGlobalPosition()
<span>public</span> <span>double</span> getGlobalRotation()
public double getGlobalScale()</pre>
<p>These methods should compute the global position, rotation and scale of this object in world coordinates.</p>
<p><strong>Note: </strong>You are not provided a GL context in this case, so you cannot use GL methods to implement this. 
You should do this computation directly, using the matrices provided by 
MathUtil.</p>
<pre class="prettyprint linenums">public void setParent(GameObject parent)</pre>
<p><span>This method already handles moving an object to a different parent in the tree, but at the moment this causes the object to change location, orientation and scale. You should rewrite it so that it modifies the objects local transformation so that its global transformation is not changed when it moves.</span></p>
<p><strong>Example</strong>: consider the scene-tree</p>
<pre>    <strong>ROOT</strong> p = (0,0), r = 0, s =1
        <strong>Object 1</strong> p = (1,1), r = 0, s = 1
            <strong>Object 2</strong> p = (0, 1), r = 0, s = 3
        <strong>Object 3</strong> p = (-1,-1), r = 90, s = 2</pre>
<p><span>Each object is specified with its local position, rotation and scale.</span></p>
<p>Currently the <strong>global</strong> position of <strong>Object 2</strong> is (1,2). Its global rotation is 0 and its global scale is 3.</p>
<p>If we change its parent to <strong>Object 3,</strong> the current code creates the follow scene tree:</p>
<pre>    <strong>ROOT</strong> p = (0,0), r = 0, s =1
        <strong>Object 1</strong> p = (1,1), r = 0, s = 1
        <strong>Object 3</strong> p = (-1,-1), r = 90, s = 2
            <strong>Object 2</strong> p = (0, 1), r = 0, s = 3</pre>
<p>Object 2 now has global position = (-3,-1), rotation = 90, scale = 6.</p>
<p>You need to change the local transform for Object 2 so that it maintains its <strong>original</strong> global transform. I.e:</p>
<pre>    <strong>ROOT</strong> p = (0,0), r = 0, s =1
        <strong>Object 1</strong> p = (1,1), r = 0, s = 1
        <strong>Object 3</strong> p = (-1,-1), r = 90, s = 2
            <strong>Object 2</strong> p = (1.5, -1), r = -90, s = 3/2</pre>
<p> </p>

<p>We have provided a class called GameObjectTest.java. This is a junit test class that you can use as a starting point to test your GameObject class.

</p><h4>PolygonalGameObject</h4>

<p> PolygonalGameObject is a class that extends GameObject and can draw Polygonal shapes.
</p><pre><span>public</span> <span>void</span> drawSelf(GL2 gl)</pre>
<p>This method should draw the object's polygon using appropriate glVertex() calls. You can assume in this method that the 
model-view transformation has already been appropriately set by GameObject.draw() so you do not have to transform the points.</p>

<p>We will only be testing your class with convex polygons, so you do not have to consider the more difficult case of concave polygons. Of course feel free to try it for fun :)



</p><h4>CircularGameObject</h4>
<p>
CircularGameObject is a class that you must write. There is no stub provided. It should provide similar functionality to the PolygonalGameObject class but obviously be specialised to be able to draw circles. You should approximate your circles by drawing a 32 sided polygon. 
</p><p>The constructors you MUST implement are:

</p><pre>//Create a CircularGameObject with centre 0,0 and radius 1
public CircularGameObject(GameObject parent, double[] fillColour
                                             double[] lineColour);

//Create a CircularGameObject with centre 0,0 and a given radius
public CircularGameObject(GameObject parent, double radius,double[] fillColour
                                                           double[] lineColour);

</pre>

<p>
It should also provide all similar functionality as the 
PolygonalGameObject class ie. You should be able to get points and 
draw the CircularGameObject etc.

</p><p>Note: You can extend/use any classes or implement any interfaces you think 
are appropriate to complete this class. You can include additional methods.


</p><h4>LineGameObject</h4>
<p>
LineGameObject is a class that you must write. There is no stub provided. It should provide similar functionality to the PolygonalGameObject class but instead be able to draw a line. 

</p><p>The constructors you MUST implement are:

</p><pre>//Create a LineGameObject from (0,0) to (1,0)
public LineGameObject(GameObject parent, double[] lineColour);

//Create a LineGameObject from (x1,y1) to (x2,y2)
public LineGameObject(GameObject parent,  double x1, double y1,
                                          double x2, double y2,
                                          double[] lineColour);

</pre>

<p>
It should also provide all the same functionality as the 
PolygonalGameObject class ie. You should be able to get and set points and 
draw the LineObject etc.

</p><p>Note: You can extend any classes or implement any interfaces you think are appropriate to complete this class. You can include additional methods.



</p><h4>Camera</h4>
<pre><span>public</span> <span>void</span> setView(GL2 <span>gl</span>)</pre>
<p>This method must set the view transform to account for the camera's current position, orientation and scale.&nbsp;</p>
<p>It should also clear&nbsp;the viewport to the given background colour.</p>

<h4>MyCoolGameObject</h4>
You need to write your own GameObject, that must extend GameObject (or 
another class that extends GameObject). The criteria for this class are as 
follows:
<ul>
<li>Your object must have at least 2 descendants. In other words it must 
have at least 2 children, or have a child that also has a child. These 
children can be PolygonalGameObjects, CircularGameObjects, LineGameObjects 
or can be classes of your own design that extend GameObject.
</li><li> You must provide a default constructor for your object. We will be 
testing your object by using a default constructor. And will run it with 
the TestMyCoolGameObject.java class provided. 
</li><li> Your object should not 'break' when we translate it, rotate it or 
scale it.
</li><li> You do not need to provide any animation for this object. 
</li></ul>


<h3>Bonus 1: Collision Detection</h3>
<p>As an extension to the assignment, implement simple &nbsp;<strong>collision testing</strong>. Add a method on GameEngine:</p>
<pre>public List&lt;GameObject&gt; collision(double[] p)</pre>
<p>which takes a point in world coordinates and returns a list of any PolygonalGameObjects, CircularGameObjects or LineGameObjects in the scene-graph which contain that point.</p>

<h3>Bonus 2: Write a game</h3>
<p>Write a game with your engine. 
</p><p>Any serious attempt will get up to 0.5 bonus mark as decided by your 
tutor.
</p><p>
The best 2 games from each tutorial class (as judged by the tutor and or class vote) get put into running for the best game in 
 the course. These games will all get 1 bonus mark. 
</p><p>The top game as voted by you will get 2 bonus marks, second and 
third top games will get 1.5 bonus marks.
 
</p>

<h1>Marking</h1>
<p>This assignment is worth 15% of your final mark</p>
<p>Marks are assigned as follows:</p>
<table class="table table-bordered table-striped" style="width: 500px;">
<thead>
<tr>
<th scope="col">Component</th>
<th scope="col">Mark</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>MathUtils methods</p>
</td>
<td>0.5</td>
</tr>
<tr>
<td>
<p>GameObject.draw()</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>GameObject.getGlobalTranslation()<br>
<span>GameObject.getGlobalRotation()<br>
			GameObject.getGlobalScale()</span></td>
<td>3</td>
</tr>
<tr>
<td>GameObject.setParent()</td>
<td>2.5</td>
</tr>
<tr>
<td>PolygonalGameObject.draw()</td>
<td>1.5</td>
</tr>

<tr>
<td>CircularGameObject
<br>LineGameObject
</td>
<td>2</td>
</tr>

<tr>
<td>Camera.setView()</td>
<td>1.5</td>
</tr>

<tr>
<td>MyCoolGameObject</td>
<td>2</td>
</tr>

<tr>
<td>Impressive Games</td>
<td>bonus 2</td>
</tr>

<tr>
<td>GameEngine.collision()</td>
<td>bonus 2</td>
</tr>
</tbody>
</table>
Note: The maximum mark for the assignment is 18.
<p>Marks are based on <strong>correctness</strong> and 
<strong>clarity</strong> of code ( My Cool Game 
Object and Impressive Games bonus marks are also marked on being 
cool or funny or beautiful etc ).</p>

<h2>Tests</h2>
We have provided some test files  to help you 
test your assignment. These are not 
comprehensive and will not guarantee that your program is perfect, but are a good place to start. 
They include the following
<p>
</p><ul>
<li>JUnit tests for the MathUtils and GameObject class. 
They 
use <a href="http://junit.org/" target="_blank">JUnit 4</a>.</li> <li>

<p>We have provided a class called TestShapes.java. This is a simple class with a main method that creates a polygon, 2 circles and 2 lines.  This file can be used as a starting point for testing your PolygonalGameObject, CircularGameObject and LineGameObject. Once you have implemented the relevant classes (including the Camera which is used in this test class), it should display the following:
</p><p> 
<img src="./Assignment 1_files/TestShapes.PNG"> 
Note: You still need to do your own testing. This only tests a few basics.
</p></li><li> We have provided a class called TestMyCoolGameObject.java. This is a 
simple class that uses your MyCoolGameObject class.

</li></ul>
We have also provided the source of <a href="http://www.cse.unsw.edu.au/~cs3421/17s2/assignments/ass1-sailing.zip" target="_blank">a sailing game</a> as an example of a use-case for the 
engine you are developing. It is also another way to check if your 
code is working and to get inspiration for the bonus stage.


<hr>

<h1>Submission</h1>

You can submit via webcms or via the command line using give. You must submit your bonus game (if you have one) separately from the rest of the assignment.


</body></html>